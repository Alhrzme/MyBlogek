<?php

namespace AppBundle\DataFixtures\ORM;

use AppBundle\Entity\Post;
use Doctrine\Common\DataFixtures\AbstractFixture;
use Doctrine\Common\DataFixtures\OrderedFixtureInterface;
use Doctrine\Common\Persistence\ObjectManager;

class LoadPostData extends AbstractFixture implements OrderedFixtureInterface
{

    /**
     * Load data fixtures with the passed EntityManager
     *
     * @param ObjectManager $manager
     */
    public function load(ObjectManager $manager) {
        $post = new Post();
        $post->setUser($this->getReference('fixt_user'));
        $post->setTitle('числа Кармайкла');
        $post->setBody('Числа, «обманывающие» тест Ферма, называются числами Кармайкла (Carmichael numbers), и про них почти ничего неизвестно, кроме того, что они очень редки. Существует 255 чисел Кармайкла, меньших 100 000 000. Несколько первых — 561, 1105, 1729, 2465, 2821 и 6601.\n При проверке на простоту больших чисел, выбранных случайным образом, шанс наткнуться на число, «обманывающее» тест Ферма, меньше, чем шанс, что космическое излучение заставит компьютер сделать ошибку при вычислении «правильного» алгоритма. То, что по первой из этих причин алгоритм считается неадекватным, а по второй нет, показывает разницу между математикой и техникой.');
        $post->setSummary('Числа, «обманывающие» тест Ферма, называются числами Кармайкла (Carmichael numbers), и про них почти ничего неизвестно, кроме того, что они очень редки. Существует 255 чисел Кармайкла, меньших 100 000 000. Несколько первых — 561, 1105, 1729, 2465, 2821 и 6601.');
        $post->addTag($this->getReference('tag1'));
        $post->addTag($this->getReference('tag2'));
        $manager->persist($post);

        $post2 = new Post();
        $post2->setUser($this->getReference('fixt_user2'));
        $post2->setTitle('Алгоритм Евлида');
        $post2->setBody("Этот алгоритм основан на том, что если r есть остаток от деления a на b, то общие делители a и b в точности те же, что и общие делители b и r. Таким образом, можно воспользоваться уравнением НОД(a, b) = НОД(b, r),чтобы последовательно свести задачу нахождения НОД к задаче нахождения НОД все меньших и меньших пар целых чисел. Алгоритм Евклида называется так потому, что он встречается в Началах Евклида (книга 7, ок. 300 г. до н.э.).\n По утверждению Кнута (Knuth 1973), его можно считать самым старым из известных нетривиальных алгоритмов. Древнеегипетский метод умножения (упражнение 1.18), разумеется, древнее, но, как объясняет Кнут, алгоритм Евклида — самый старый алгоритм, представленный в виде общей процедуры, а не через набор иллюстрирующих примеров.");
        $post2->setSummary('Этот алгоритм основан на том, что если r есть остаток от деления a на b, то общие делители a и b в точности те же, что и общие делители b и r.');
        $post2->addTag($this->getReference('tag1'));
        $manager->persist($post2);

        $post3 = new Post();
        $post3->setUser($this->getReference('fixt_user2'));
        $post3->setTitle('Рекурентные уравнения');
        $post3->setBody('Когда алгоритм рекурсивно вызывает сам себя, зачастую время его работы можно описать с помощью рекуррентного выражения (рекуррентности), которое выражает полное время, требующееся для решения задачи размером n, через время решения задач для меньших входных данных. Затем можно прибегнуть к соответствующему математическому аппарату для решения рекуррентности и получить границы производительности алгоритма.');
        $post3->setSummary('Когда алгоритм рекурсивно вызывает сам себя, зачастую время его работы можно описать с помощью рекуррентного выражения (рекуррентности), которое выражает полное время, требующееся для решения задачи размером n, через время решения задач для меньших входных данных. Затем можно прибегнуть к соответствующему математическому аппарату для решения рекуррентности и получить границы производительности алгоритма. ');
        $post3->addTag($this->getReference('tag2'));
        $manager->persist($post3);

        $post4 = new Post();
        $post4->setUser($this->getReference('fixt_user2'));
        $post4->setTitle('Метод "Разделяй и властвуй"');
        $post4->setBody('Сложная задача разделяется на несколько простых, которые подобны исходной задаче, но имеют меньший объем. Далее эти вспомогательные задачи решаются рекурсивным методов, после чего полученные решения комбинируются для получения решения исходной задачи. Парадигма, лежащая в основе метода декомпозиции "разделяй и властвуй"  на каждом уровне рекурсии включает в себя 3 шага: \n1) Разделение задач на несколько подзадач, которые представляют собой меньшие экземпляры той же самой задачи. \n2) Властвование над задачами путем их рекурсивного решения. Если задачи достаточно малы, такие задачи могут решаться непосредственно. /n3) Комбинирование решений подзадач в решение исходной задачи.');
        $post4->setSummary('Сложная задача разделяется на несколько простых, которые подобны исходной задаче, но имеют меньший объем. Далее эти вспомогательные задачи решаются рекурсивным методов, после чего полученные решения комбинируются для получения решения исходной задачи.');
        $post4->addTag($this->getReference('tag2'));
        $manager->persist($post4);

        $manager->flush();

        $this->addReference('post1', $post);
        $this->addReference('post2', $post2);
        $this->addReference('post3', $post3);
        $this->addReference('post4', $post4);
    }

    /**
     * Get the order of this fixture
     *
     * @return integer
     */
    public function getOrder() {
        return 3;
    }
}